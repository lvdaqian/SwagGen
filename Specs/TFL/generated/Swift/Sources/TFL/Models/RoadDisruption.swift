//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation
import JSONUtilities

public class RoadDisruption: JSONDecodable, JSONEncodable, PrettyPrintable {

    /** Describes the nature of disruption e.g. Traffic Incidents, Works */
    public var category: String?

    /** Full text of comments describing the disruption, including details of any road closures and diversions, where appropriate. */
    public var comments: String?

    /** The Ids of affected corridors, if any. */
    public var corridorIds: [String]?

    /** Text of the most recent update from the LSTCC on the state of the
             disruption, including the current traffic impact and any advice to
             road users. */
    public var currentUpdate: String?

    /** The time when the last CurrentUpdate description was recorded, 
            or null if no CurrentUpdate has been applied. */
    public var currentUpdateDateTime: Date?

    /** The date and time on which the disruption ended. For planned disruptions, this date will have a valid value. For unplanned 
            disruptions in progress, this field will be omitted. */
    public var endDateTime: Date?

    /** Geography version of Point for output as GeoJSON.
            Can not use Geometry in a consistent way as non-TIMS disruptions do not have a polygon */
    public var geography: DbGeography?

    /** GeoJSON formatted latitude/longitude (WGS84) pairs forming an enclosed polyline or polygon. The polygon will only be included where affected streets information
            is not available for the disruption, would be inappropriate (e.g. a very large number of streets), or is centred on an area without streets (e.g. a football stadium). */
    public var geometry: DbGeography?

    /** True if any of the affected Streets have a "Full Closure" status, false otherwise. A RoadDisruption that has HasClosures is considered a 
            Severe or Serious disruption for severity filtering purposes. */
    public var hasClosures: Bool?

    /** Unique identifier for the road disruption */
    public var id: String?

    /** True if the disruption is planned on a future date that is open to change */
    public var isProvisional: Bool?

    /** The date and time on which the disruption was last modified in the system. This information can reliably be used by a developer to quickly
            compare two instances of the same disruption to determine if it has been changed. */
    public var lastModifiedTime: Date?

    /** This describes the level of potential impact on traffic operations of the disruption. 
            High = e.g. a one-off disruption on a major or high profile route which will require a high level of operational attention 
            Medium = This is the default value 
            Low = e.g. a frequently occurring disruption which is well known */
    public var levelOfInterest: String?

    /** The text of any associated link */
    public var linkText: String?

    /** The url of any associated link */
    public var linkUrl: String?

    /** Main road name / number (borough) or preset area name where the disruption is located. This might be useful for a map popup where space is limited. */
    public var location: String?

    /** An ordinal of the disruption based on severity, level of interest and corridor. */
    public var ordinal: Int?

    /** Latitude and longitude (WGS84) of the centroid of the disruption, stored in a geoJSON-formatted string. */
    public var point: String?

    public var publishEndDate: Date?

    /** TDM Additional properties */
    public var publishStartDate: Date?

    public var recurringSchedules: [RoadDisruptionSchedule]?

    public var roadDisruptionImpactAreas: [RoadDisruptionImpactArea]?

    public var roadDisruptionLines: [RoadDisruptionLine]?

    /** Any associated road project */
    public var roadProject: RoadProject?

    /** A description of the severity of the disruption. */
    public var severity: String?

    /** The date and time which the disruption started. For a planned disruption (i.e. planned road works) this date will be in the future.
            For unplanned disruptions, this will default to the date on which the disruption was first recorded, but may be adjusted by the operator. */
    public var startDateTime: Date?

    /** This describes the status of the disruption.  
            Active = currently in progress 
            Active Long Term = currently in progress and long term
            Scheduled = scheduled to start within the next 180 days
            Recurring Works = planned maintenance works that follow a regular routine or pattern and whose next occurrence is to start within the next 180 days.
            Recently Cleared = recently cleared in the last 24 hours
            Note that the status of Scheduled or Recurring Works disruptions will change to Active when they start, and will change status again when they end. */
    public var status: String?

    /** A collection of zero or more streets affected by the disruption. */
    public var streets: [Street]?

    /** Describes the sub-category of disruption e.g. Collapsed Manhole, Abnormal Load */
    public var subCategory: String?

    public var timeFrame: String?

    /** URL to retrieve this road disruption */
    public var url: String?

    public init(category: String? = nil, comments: String? = nil, corridorIds: [String]? = nil, currentUpdate: String? = nil, currentUpdateDateTime: Date? = nil, endDateTime: Date? = nil, geography: DbGeography? = nil, geometry: DbGeography? = nil, hasClosures: Bool? = nil, id: String? = nil, isProvisional: Bool? = nil, lastModifiedTime: Date? = nil, levelOfInterest: String? = nil, linkText: String? = nil, linkUrl: String? = nil, location: String? = nil, ordinal: Int? = nil, point: String? = nil, publishEndDate: Date? = nil, publishStartDate: Date? = nil, recurringSchedules: [RoadDisruptionSchedule]? = nil, roadDisruptionImpactAreas: [RoadDisruptionImpactArea]? = nil, roadDisruptionLines: [RoadDisruptionLine]? = nil, roadProject: RoadProject? = nil, severity: String? = nil, startDateTime: Date? = nil, status: String? = nil, streets: [Street]? = nil, subCategory: String? = nil, timeFrame: String? = nil, url: String? = nil) {
        self.category = category
        self.comments = comments
        self.corridorIds = corridorIds
        self.currentUpdate = currentUpdate
        self.currentUpdateDateTime = currentUpdateDateTime
        self.endDateTime = endDateTime
        self.geography = geography
        self.geometry = geometry
        self.hasClosures = hasClosures
        self.id = id
        self.isProvisional = isProvisional
        self.lastModifiedTime = lastModifiedTime
        self.levelOfInterest = levelOfInterest
        self.linkText = linkText
        self.linkUrl = linkUrl
        self.location = location
        self.ordinal = ordinal
        self.point = point
        self.publishEndDate = publishEndDate
        self.publishStartDate = publishStartDate
        self.recurringSchedules = recurringSchedules
        self.roadDisruptionImpactAreas = roadDisruptionImpactAreas
        self.roadDisruptionLines = roadDisruptionLines
        self.roadProject = roadProject
        self.severity = severity
        self.startDateTime = startDateTime
        self.status = status
        self.streets = streets
        self.subCategory = subCategory
        self.timeFrame = timeFrame
        self.url = url
    }

    public required init(jsonDictionary: JSONDictionary) throws {
        category = jsonDictionary.json(atKeyPath: "category")
        comments = jsonDictionary.json(atKeyPath: "comments")
        corridorIds = jsonDictionary.json(atKeyPath: "corridorIds")
        currentUpdate = jsonDictionary.json(atKeyPath: "currentUpdate")
        currentUpdateDateTime = jsonDictionary.json(atKeyPath: "currentUpdateDateTime")
        endDateTime = jsonDictionary.json(atKeyPath: "endDateTime")
        geography = jsonDictionary.json(atKeyPath: "geography")
        geometry = jsonDictionary.json(atKeyPath: "geometry")
        hasClosures = jsonDictionary.json(atKeyPath: "hasClosures")
        id = jsonDictionary.json(atKeyPath: "id")
        isProvisional = jsonDictionary.json(atKeyPath: "isProvisional")
        lastModifiedTime = jsonDictionary.json(atKeyPath: "lastModifiedTime")
        levelOfInterest = jsonDictionary.json(atKeyPath: "levelOfInterest")
        linkText = jsonDictionary.json(atKeyPath: "linkText")
        linkUrl = jsonDictionary.json(atKeyPath: "linkUrl")
        location = jsonDictionary.json(atKeyPath: "location")
        ordinal = jsonDictionary.json(atKeyPath: "ordinal")
        point = jsonDictionary.json(atKeyPath: "point")
        publishEndDate = jsonDictionary.json(atKeyPath: "publishEndDate")
        publishStartDate = jsonDictionary.json(atKeyPath: "publishStartDate")
        recurringSchedules = jsonDictionary.json(atKeyPath: "recurringSchedules")
        roadDisruptionImpactAreas = jsonDictionary.json(atKeyPath: "roadDisruptionImpactAreas")
        roadDisruptionLines = jsonDictionary.json(atKeyPath: "roadDisruptionLines")
        roadProject = jsonDictionary.json(atKeyPath: "roadProject")
        severity = jsonDictionary.json(atKeyPath: "severity")
        startDateTime = jsonDictionary.json(atKeyPath: "startDateTime")
        status = jsonDictionary.json(atKeyPath: "status")
        streets = jsonDictionary.json(atKeyPath: "streets")
        subCategory = jsonDictionary.json(atKeyPath: "subCategory")
        timeFrame = jsonDictionary.json(atKeyPath: "timeFrame")
        url = jsonDictionary.json(atKeyPath: "url")
    }

    public func encode() -> JSONDictionary {
        var dictionary: JSONDictionary = [:]
        if let category = category {
            dictionary["category"] = category
        }
        if let comments = comments {
            dictionary["comments"] = comments
        }
        if let corridorIds = corridorIds {
            dictionary["corridorIds"] = corridorIds
        }
        if let currentUpdate = currentUpdate {
            dictionary["currentUpdate"] = currentUpdate
        }
        if let currentUpdateDateTime = currentUpdateDateTime?.encode() {
            dictionary["currentUpdateDateTime"] = currentUpdateDateTime
        }
        if let endDateTime = endDateTime?.encode() {
            dictionary["endDateTime"] = endDateTime
        }
        if let geography = geography?.encode() {
            dictionary["geography"] = geography
        }
        if let geometry = geometry?.encode() {
            dictionary["geometry"] = geometry
        }
        if let hasClosures = hasClosures {
            dictionary["hasClosures"] = hasClosures
        }
        if let id = id {
            dictionary["id"] = id
        }
        if let isProvisional = isProvisional {
            dictionary["isProvisional"] = isProvisional
        }
        if let lastModifiedTime = lastModifiedTime?.encode() {
            dictionary["lastModifiedTime"] = lastModifiedTime
        }
        if let levelOfInterest = levelOfInterest {
            dictionary["levelOfInterest"] = levelOfInterest
        }
        if let linkText = linkText {
            dictionary["linkText"] = linkText
        }
        if let linkUrl = linkUrl {
            dictionary["linkUrl"] = linkUrl
        }
        if let location = location {
            dictionary["location"] = location
        }
        if let ordinal = ordinal {
            dictionary["ordinal"] = ordinal
        }
        if let point = point {
            dictionary["point"] = point
        }
        if let publishEndDate = publishEndDate?.encode() {
            dictionary["publishEndDate"] = publishEndDate
        }
        if let publishStartDate = publishStartDate?.encode() {
            dictionary["publishStartDate"] = publishStartDate
        }
        if let recurringSchedules = recurringSchedules?.encode() {
            dictionary["recurringSchedules"] = recurringSchedules
        }
        if let roadDisruptionImpactAreas = roadDisruptionImpactAreas?.encode() {
            dictionary["roadDisruptionImpactAreas"] = roadDisruptionImpactAreas
        }
        if let roadDisruptionLines = roadDisruptionLines?.encode() {
            dictionary["roadDisruptionLines"] = roadDisruptionLines
        }
        if let roadProject = roadProject?.encode() {
            dictionary["roadProject"] = roadProject
        }
        if let severity = severity {
            dictionary["severity"] = severity
        }
        if let startDateTime = startDateTime?.encode() {
            dictionary["startDateTime"] = startDateTime
        }
        if let status = status {
            dictionary["status"] = status
        }
        if let streets = streets?.encode() {
            dictionary["streets"] = streets
        }
        if let subCategory = subCategory {
            dictionary["subCategory"] = subCategory
        }
        if let timeFrame = timeFrame {
            dictionary["timeFrame"] = timeFrame
        }
        if let url = url {
            dictionary["url"] = url
        }
        return dictionary
    }

    /// pretty prints all properties including nested models
    public var prettyPrinted: String {
        return "\(type(of: self)):\n\(encode().recursivePrint(indentIndex: 1))"
    }
}
